const 的作用：
1. 修饰变量/入参，表示变量不会改变；即使是通过 const_cast<int> 也并不能修改变量值，const_cast只是用于入参的常量转变；
2. 修饰指针：表示常量指针或指针常量；
3. 修饰形参引用，避免拷贝、避免函数对入参的修改；
4. 修饰类方法，不会改变成员变量；

static 的作用：
1. 修饰普通变量：在头文件中定义 `static int v;` ，那么多个文件 include 该头文件，都只能在各自的cpp文件中使用；
1. 定义普通函数：表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令行数重名，可以将函数定义为static。
1. 修饰局部变量：改变变量的生命周期，使变量存放在静态区；
1. 修饰成员函数：表示类方法，只能访问类变量或类方法；
1. 修饰成员变量：表示类变量，所有对象共享；

this 指针：
1. this 是每一个非静态成员函数中都有的特殊指针，指向正在被该成员函数操作的那个对象；
1. 调用成员函数时，编译器先将对象的地址传给this，然后调用成员函数；
1. 不能对this赋值，因为是一个右值，所以不能对this取地址；
1. 在以下场景中，经常需要显式引用this指针：
    - 为实现对象的链式引用；
    - 为避免对同一对象进行赋值操作；
    - 在实现一些数据结构时，如list中 `next->pre = this;`

inline:
1. 将内联函数在被调用出展开；
1. 不需要执行进入函数的步骤，直接执行函数体；
1. 相比于宏定义，多了类型检查，具有函数特性；
1. 不能有递归、循环、switch等复杂操作；
1. 在类声明中定义的函数，除了虚函数，默认都是内联的；

编译器对inline函数的处理步骤：
1. 将inline函数复制到调用处；
1. 为inline函数中的局部变量分配内存空间；
1. 将输入参数和返回参数映射到调用方法的局部变量空间中；
1. 如果inline函数有多个返回值，将其变为goto分支；

内联函数在运行时可以调试，宏定义不可以；

虚函数可以内联吗？可以，但当虚函数表现出多态性的时候不能内联，因为内联是在编译器完成的，而多态性是运行期表现的，inline virtual 网易可以内联的时候是编译器知道所调用的对象是哪个类，只有编译器具有实际对象而不是对象的指针或引用时，才会发生；

字节对齐：
```cpp
#pragma pack(push)
#pragma pack(2) // 指定字节对齐方式
#pragma pack(pop)
```
位域：
```cpp
// sizeof 为 2
// 按照定义的顺序，先定义的在低位，后定义的在高位
class BitDemo{
    char v1: 1;
    short v2: 4;
    char v3: 2;
};
```

联合union：
- 默认访问控制符为public；
- 可以含有构造函数和析构函数；
- 不能继承和被继承；
- 不能有虚函数；

extern "C": 被 extern 限定的函数或变量是 extern 类型的； 被 `extern "C"` 修饰的变量和函数是按照C语言方式编译和链接的；如果希望链接c编译器编译出的目标文件，需要使用extern "C";
```cpp
#ifdef __cplusplus
extern "C"{
#endif

void memset(void*, int, size_t);

#ifdef __cplusplus
}
#endif
```

可以同时在cpp中定义同名的结构体和函数，那么在声明结构体时需要显示地声明为 `struct StructName instance`；

class 和 struct 的区别：class适合作为对象的实现体，默认private访问控制，struct适合作为数据结构的实现体，默认public访问控制；

explict 关键字：声明类构造函数必须显式调用，只能用于修饰单参构造函数；

在c++11中引入`nullptr`关键字的作用：NULL在C++中等价于0，在出现`void f(int)` 和 `void f(void*)` 时，`f(NULL)` 会出现调用歧义，而 nullptr 就是表示空指针，因此`f(nullptr)`可以正确地调用`void f(void*)`。

c++ 中有4个智能指针，auto_ptr, shared_ptr, weak_ptr, unique_ptr，其中后三个是c++支持的，第一个被c++11弃用。

智能指针的原理：因为智能指针是一个类，但超出了类的作用域时，会自动调用智能指针类的析构函数，析构函数会自动释放资源。
- auto_ptr: 智能指针可以像类的原始指针一样访问类的public成员，成员函数get返回一个原始的指针，成员函数reset重新绑定指向的对象，原对象会被释放，访问auto_ptr的成员函数时用的是`.`，访问指向对象的成员时使用的是`->`。我们对智能指针赋值时，如 `p2=p1`，p2会接管p1原来的内存管理权，ptest会变为空指针，如果p2原来不为空，则它会释放原来的资源，应该避免把auto放到容器中，因为算法对容器操作时，很难避免STL内部对容器实现赋值传递操作，判断一个智能指针是否为空，应该使用 `if(p.get()==NULL)`。auto_ptr 的release只是释放了对资源的控制权。


<!-- 移动语义move semantic和完美转发perfect forward：新标准定义了lvalue和rvalue，并允许函数依照这两种不同的类型进行重载。通过对右值的重新定义语言实现了移动语义(move semantic)和完美转发(perfect forwarding)，通过这种方法，C++实现了在保留原有的语法并不改动已存在的代码的基础上提升代码性能的目的。 -->
左值和右值：凡是真正地存在内存中，而不是寄存器中的值就是左值，其余的都是右值

- unique_ptr 是用于取代c++98中auto_ptr的产物，在c++98的时候还没有移动语义的支持，因此对于atuo_ptr的控制器转移的实现没有核心元素的支持，但还是实现了auto_ptr的移动语义，这样带来的一些问题是拷贝构造函数和复制操作重载函数不够完美，具体体现就是把auto_ptr作为函数参数传进去的时候控制权转移，转移到函数参数，当函数返回的时候并没有一个控制权移交的过程，所以过了函数调用，原先的auto_ptr就失效了。unique_ptr的拷贝构造函数已经私有化，因此 `void f(unique<A> p)` 在执行 `f(p)` 时会出错，需要使用 `f(move(p))` 显式说明控制权的转移。

- share_ptr：资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数 use_count() 来查看资源的所有者个数。除了可以通过传入 auto_ptr/unique_ptr/weak_ptr来构造。当我们调用release时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

- weak_ptr: 用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放，它是对对象的一种弱引用，不会增加对象的引用计数；我们不能直接通过weak_ptr访问对象的方法，应该先把它转换为shared_ptr，例如 `shared_ptr<B> p = wk_ptr.lock(); p->show();`，将一个shared_ptr 赋值给一个 weak_ptr 对象


在头文件中可以包含的内容：声明仅仅是将一个符号引入到一个作用域中，注意：
- 将具有外部链接的定义放在头文件中几乎一定会有编译错误。因为如果该头文件被多个源文件包含，那么就会存在多个定义，链接是就会出错；
- 在头文件中放置内部链接的定义是合法的，但不推荐使用，因为头文件被包含到多个源文件中时，在每个编译单元中都有自己的实体存在，大量消耗内存空间，影响机器性能；

static 和 非static 函数/变量的主要区别在于是否在生成的目标文件中包含该实体的symbol，因此该问题只会在链接的时候出现，如果在其他的文件中只是声明了一个其他文件的static函数，并不会在链接时出错，因为没有没有使用就没有链接，一旦使用，就会出现符号找不到的链接错误。

拷贝构造函数是一种特殊的构造函数，函数的名称必须和类名称一致，它必须的一个参数是本类型的一个引用变量。c++默认会为类提供无参构造函数和默认拷贝构造函数，如果用户定义了拷贝构造函数，那么默认无参构造函数不再提供，而定义了无参构造，默认拷贝构造仍然有效；默认拷贝构造函数仅仅使用老对象的数据成员对新对象的数据成员进行一一赋值。

默认拷贝构造函数是浅拷贝，不涉及动态成员。

拷贝构造函数的调用时机：
- 对象以值传递的方式传入函数参数；
- 对象以值传递的方式从函数返回；
- 对象需要通过另一个对象进行初始化，如 `A x2 = x1;` 或 `A x2(x1);`

防止默认拷贝发生的方法（可能会存在大量的时间、空间消耗）：声明一个私有拷贝构造函数。

构造函数能不能是虚函数？答：不能，虚函数对应一个vtable，对象都没有完成构建，不可能有虚表指针；构造函数本来就需要构建真实的子类，不需要多态性；编译就不能通过。

能不能在构造函数中调用虚函数？答：可以，但是没有意义，因为虚函数是为了多态性，而在父类构造函数中调用的是父类的虚函数，在子类构造函数中调用的是子类的虚函数，并没有体现多态性。(多态性的体现：在父类的函数中调用虚函数，会根据具体的类型动态决定执行的代码，而在构造函数中调用虚函数，调用的一定是父类的函数，那么动态性就消失了。)

能不能在析构函数中调用虚函数？答：与在构造函数中调用虚函数同理。

在c++11中提出了enum class用于替代enum，新的enum的作用域不再是全局的，限定了作用域，不能隐式转变为其他类型，可以指定类型，例如 `enum class Color: unsigned char {red, blue, green};`；

引用：
    - 左值引用：常规引用，一般表示对象的身份；
    - 右值引用：必须绑定到一个右值(一个临时对象，将要销毁的对象)的引用，一般表示对象的值；

在函数重载时，参数匹配关系：
```cpp
#include <iostream>
using namespace std;

void f(const int& v){
    cout << "f(const int&)" << endl;
}
void f(int& v){
    cout << "f(int&)" << endl;
}
void f(int&& v){
    cout << "f(int&&)" << endl;
}

int main(){
    const int v1 = 1;
    int v2 = 1;
    f(v1);  // 输出 f(const int&)
    f(v2);  // 输出 f(int&)
    f(1);   // 输出 f(int&&)
}
```
右值引入的目的：
- 临时对象非必要的昂贵的拷贝操作；
- 模板函数中如何按照参数的实际类型进行转发

c++中，所有的值必定属于左值、将亡值、纯右值中的一种。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、lambda表达式等都是纯右值。将亡值与右值引用相关的表达式，如将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等；

虚表指针：在含有虚函数类的对象中，指向虚函数表的，在运行时存放在实例的头部；
虚函数表：在程序的只读数据段中存放虚函数地址，如果派生类中实现了某个虚函数，则在虚表中覆盖原来基类的虚函数指针，在编译器根据类的声明创建；

1. 公有继承(public)：公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。

2. 私有继承(private)：私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

3. 保护继承(protected)：保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。

|父类成员类型|public|protected|private|
|---|---|---|---|
|共有继承|public|protected|不可见|
|保护继承|protected|protected|不可见|
|私有继承|private|private|不可见|

下面列出三种不同的继承方式的基类特性和派生类特性。

虚继承用于解决多继承下的菱形继承问题。

模板是c++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些成员或成员函数的参数、返回值可以取得任意的类型。函数模板针对仅参数不同的函数，类模板针对仅数据成员和成员函数不同的类。


