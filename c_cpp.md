const 的作用：
1. 修饰变量/入参，表示变量不会改变；即使是通过 const_cast<int> 也并不能修改变量值，const_cast只是用于入参的常量转变；
2. 修饰指针：表示常量指针或指针常量；
3. 修饰形参引用，避免拷贝、避免函数对入参的修改；
4. 修饰类方法，不会改变成员变量；

static 的作用：
1. 修饰普通变量：在头文件中定义 `static int v;` ，那么多个文件 include 该头文件，都只能在各自的cpp文件中使用；
1. 定义普通函数：表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命令行数重名，可以将函数定义为static。
1. 修饰局部变量：改变变量的生命周期，使变量存放在静态区；
1. 修饰成员函数：表示类方法，只能访问类变量或类方法；
1. 修饰成员变量：表示类变量，所有对象共享；

this 指针：
1. this 是每一个非静态成员函数中都有的特殊指针，指向正在被该成员函数操作的那个对象；
1. 调用成员函数时，编译器先将对象的地址传给this，然后调用成员函数；
1. 不能对this赋值，因为是一个右值，所以不能对this取地址；
1. 在以下场景中，经常需要显式引用this指针：
    - 为实现对象的链式引用；
    - 为避免对同一对象进行赋值操作；
    - 在实现一些数据结构时，如list中 `next->pre = this;`

inline:
1. 将内联函数在被调用出展开；
1. 不需要执行进入函数的步骤，直接执行函数体；
1. 相比于宏定义，多了类型检查，具有函数特性；
1. 不能有递归、循环、switch等复杂操作；
1. 在类声明中定义的函数，除了虚函数，默认都是内联的；

编译器对inline函数的处理步骤：
1. 将inline函数复制到调用处；
1. 为inline函数中的局部变量分配内存空间；
1. 将输入参数和返回参数映射到调用方法的局部变量空间中；
1. 如果inline函数有多个返回值，将其变为goto分支；

内联函数在运行时可以调试，宏定义不可以；

虚函数可以内联吗？可以，但当虚函数表现出多态性的时候不能内联，因为内联是在编译器完成的，而多态性是运行期表现的，inline virtual 网易可以内联的时候是编译器知道所调用的对象是哪个类，只有编译器具有实际对象而不是对象的指针或引用时，才会发生；

字节对齐：
```cpp
#pragma pack(push)
#pragma pack(2) // 指定字节对齐方式
#pragma pack(pop)
```
位域：
```cpp
// sizeof 为 2
// 按照定义的顺序，先定义的在低位，后定义的在高位
class BitDemo{
    char v1: 1;
    short v2: 4;
    char v3: 2;
};
```

联合union：
- 默认访问控制符为public；
- 可以含有构造函数和析构函数；
- 不能继承和被继承；
- 不能有虚函数；

extern "C": 被 extern 限定的函数或变量是 extern 类型的； 被 `extern "C"` 修饰的变量和函数是按照C语言方式编译和链接的；如果希望链接c编译器编译出的目标文件，需要使用extern "C";
```cpp
#ifdef __cplusplus
extern "C"{
#endif

void memset(void*, int, size_t);

#ifdef __cplusplus
}
#endif
```

可以同时在cpp中定义同名的结构体和函数，那么在声明结构体时需要显示地声明为 `struct StructName instance`；

class 和 struct 的区别：class适合作为对象的实现体，默认private访问控制，struct适合作为数据结构的实现体，默认public访问控制；

explict 关键字：声明类构造函数必须显式调用，只能用于修饰单参构造函数；

在c++11中引入`nullptr`关键字的作用：NULL在C++中等价于0，在出现`void f(int)` 和 `void f(void*)` 时，`f(NULL)` 会出现调用歧义，而 nullptr 就是表示空指针，因此`f(nullptr)`可以正确地调用`void f(void*)`。

c++ 中有4个智能指针，auto_ptr, shared_ptr, weak_ptr, unique_ptr，其中后三个是c++支持的，第一个被c++11弃用。

智能指针的原理：因为智能指针是一个类，但超出了类的作用域时，会自动调用智能指针类的析构函数，析构函数会自动释放资源。
- auto_ptr: 智能指针可以像类的原始指针一样访问类的public成员，成员函数get返回一个原始的指针，成员函数reset重新绑定指向的对象，原对象会被释放，访问auto_ptr的成员函数时用的是`.`，访问指向对象的成员时使用的是`->`。我们对智能指针赋值时，如 `p2=p1`，p2会接管p1原来的内存管理权，ptest会变为空指针，如果p2原来不为空，则它会释放原来的资源，应该避免把auto放到容器中，因为算法对容器操作时，很难避免STL内部对容器实现赋值传递操作，判断一个智能指针是否为空，应该使用 `if(p.get()==NULL)`。auto_ptr 的release只是释放了对资源的控制权。


移动语义move semantic和完美转发perfect forward：新标准定义了lvalue和rvalue，并允许函数依照这两种不同的类型进行重载。通过对右值的重新定义语言实现了移动语义(move semantic)和完美转发(perfect forwarding)。
